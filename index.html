<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Gradient Background with Jewelry Glow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body, html {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }
        
        body {
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e, #16213e, #0f3460);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            position: relative;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center top, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 30%, rgba(255, 255, 255, 0.02) 60%, transparent 100%);
            pointer-events: none;
        }
        
        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
        }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.skypack.dev/three@0.132.2",
            "three/addons/": "https://cdn.skypack.dev/three@0.132.2/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        let scene, camera, renderer, model;
        let sparklePoints, sparkleGeometry, sparkleMaterial;
        let glowSphere;
        
        function createElegantEnvironment() {
            // Crear un canvas para el ambiente 360°
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Crear gradiente radial elegante
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;
            
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            
            // Gradiente desde el centro (más claro) hacia afuera (más oscuro)
            gradient.addColorStop(0, '#2a2a3a');    // Centro gris medio
            gradient.addColorStop(0.3, '#1a1a2e');  // Transición
            gradient.addColorStop(0.6, '#0f0f1a');  // Más oscuro
            gradient.addColorStop(1, '#050508');    // Borde muy oscuro
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Añadir algunos puntos de luz sutiles para elegancia
            const numLights = 8;
            for (let i = 0; i < numLights; i++) {
                const angle = (i / numLights) * Math.PI * 2;
                const distance = radius * 0.7;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                const lightGradient = ctx.createRadialGradient(x, y, 0, x, y, 30);
                lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
                lightGradient.addColorStop(0.5, 'rgba(200, 200, 255, 0.05)');
                lightGradient.addColorStop(1, 'rgba(150, 150, 200, 0)');
                
                ctx.fillStyle = lightGradient;
                ctx.fillRect(x - 30, y - 30, 60, 60);
            }
            
            // Crear textura desde el canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            
            return texture;
        }

        // Variables para rotación con inercia
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let rotationVelocityX = 0;
        let rotationVelocityY = 0;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 4);
            
            // Renderer optimizado
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            document.body.appendChild(renderer.domElement);
            
            // Lights mejoradas para joyería
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(0, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Luces específicas para crear brillos de joyería
            const keyLight = new THREE.PointLight(0xffffff, 3, 100);
            keyLight.position.set(5, 5, 5);
            scene.add(keyLight);
            
            const fillLight = new THREE.PointLight(0x6699ff, 2, 100);
            fillLight.position.set(-5, 0, 5);
            scene.add(fillLight);
            
            const rimLight = new THREE.PointLight(0xffaa55, 1.5, 100);
            rimLight.position.set(0, -5, -5);
            scene.add(rimLight);
            
            // Luz dorada para realzar el oro
            const goldLight = new THREE.PointLight(0xffd700, 2, 100);
            goldLight.position.set(3, 3, 3);
            scene.add(goldLight);
            
            const goldLight2 = new THREE.PointLight(0xffd700, 1.5, 100);
            goldLight2.position.set(-3, -3, 3);
            scene.add(goldLight2);

            // Hemisphere light para suavidad general
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);

            // Crear ambiente 360° elegante y oscuro
            const envMap = createElegantEnvironment();
            scene.environment = envMap;
            
            // Crear sistema de partículas para destellos
            createSparkles();
            
            // Crear halo de brillo
            createGlowEffect();
            
            // Función unificada para obtener posición
            function getEventPosition(event) {
                if (event.touches && event.touches.length > 0) {
                    return { x: event.touches[0].clientX, y: event.touches[0].clientY };
                }
                return { x: event.clientX, y: event.clientY };
            }
            
            // Event handlers unificados para mouse y touch
            function handleStart(event) {
                event.preventDefault();
                isDragging = true;
                const pos = getEventPosition(event);
                previousPosition.x = pos.x;
                previousPosition.y = pos.y;
            }
            
            function handleMove(event) {
                if (isDragging && model) {
                    event.preventDefault();
                    const pos = getEventPosition(event);
                    const deltaX = pos.x - previousPosition.x;
                    const deltaY = pos.y - previousPosition.y;

                    rotationVelocityY = deltaX * 0.005;
                    rotationVelocityX = deltaY * 0.0025;

                    previousPosition.x = pos.x;
                    previousPosition.y = pos.y;
                }
            }
            
            function handleEnd(event) {
                event.preventDefault();
                isDragging = false;
            }
            
            // Mouse events
            renderer.domElement.addEventListener('mousedown', handleStart);
            renderer.domElement.addEventListener('mousemove', handleMove);
            renderer.domElement.addEventListener('mouseup', handleEnd);
            renderer.domElement.addEventListener('mouseleave', handleEnd);
            
            // Touch events para móviles
            renderer.domElement.addEventListener('touchstart', handleStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleEnd, { passive: false });
            renderer.domElement.addEventListener('touchcancel', handleEnd, { passive: false });
            
            // Load GLTF model
            const loader = new GLTFLoader();
            console.log('Loading model...');
            
            loader.load(
                'https://raw.githubusercontent.com/upandunder/paso-a-paso/main/tarjeta%20grabada.glb',
                function(gltf) {
                    console.log('Model loaded successfully:', gltf);
                    model = gltf.scene;
                    
                    // Material dorado premium con brillo de joyería
                    const jewelryMaterial = new THREE.MeshPhysicalMaterial({
                        color: 0xdaa520,
                        metalness: 1.0,
                        roughness: 0.05,
                        envMap: envMap,
                        envMapIntensity: 2.5,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.01,
                        reflectivity: 1.0,
                        ior: 2.4,
                        transmission: 0.1,
                        thickness: 0.5,
                        emissive: 0x221100,
                        emissiveIntensity: 0.3
                    });
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = jewelryMaterial;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Centrar modelo
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center);
                    
                    // Escalar si es necesario
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 4 / maxDim;
                    model.scale.setScalar(scale);
                    
                    scene.add(model);
                    console.log('Model added to scene with jewelry material');
                },
                function(progress) {
                    console.log('Loading progress: ', (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.error('Error loading model: ', error);
                    
                    // Fallback cube con material de joyería
                    const geometry = new THREE.BoxGeometry(2, 2, 2);
                    const jewelryMaterial = new THREE.MeshPhysicalMaterial({
                        color: 0xdaa520,
                        metalness: 1.0,
                        roughness: 0.05,
                        envMap: envMap,
                        envMapIntensity: 2.5,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.01
                    });
                    const cube = new THREE.Mesh(geometry, jewelryMaterial);
                    scene.add(cube);
                    model = cube;
                    console.log('Added fallback cube with jewelry material');
                }
            );
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            
            // Start animation loop
            animate();
        }
        
        function createSparkles() {
            // Crear partículas de destello
            const sparkleCount = 50;
            const positions = new Float32Array(sparkleCount * 3);
            const colors = new Float32Array(sparkleCount * 3);
            const sizes = new Float32Array(sparkleCount);
            
            for (let i = 0; i < sparkleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                colors[i * 3] = 1.0;
                colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
                colors[i * 3 + 2] = 0.3 + Math.random() * 0.3;
                
                sizes[i] = Math.random() * 3 + 1;
            }
            
            sparkleGeometry = new THREE.BufferGeometry();
            sparkleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            sparkleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            sparkleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            sparkleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float sparkle = sin(time * 3.0 + position.x * 10.0) * 0.5 + 0.5;
                        gl_PointSize = size * (sparkle * 2.0 + 1.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        float dist = distance(gl_PointCoord, vec2(0.5));
                        if (dist > 0.5) discard;
                        float alpha = (1.0 - dist * 2.0) * (1.0 - dist * 2.0);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            sparklePoints = new THREE.Points(sparkleGeometry, sparkleMaterial);
            scene.add(sparklePoints);
        }
        
        function createGlowEffect() {
            // Crear halo de brillo alrededor del modelo
            const glowGeometry = new THREE.SphereGeometry(3, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(0xffd700) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float intensity = pow(0.4 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        float pulse = sin(time * 2.0) * 0.1 + 0.9;
                        gl_FragColor = vec4(color, intensity * 0.3 * pulse);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            
            glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            scene.add(glowSphere);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;

            if (model) {
                model.rotation.y += rotationVelocityY;
                model.rotation.x += rotationVelocityX;

                // Suavizar inercia
                rotationVelocityX *= 0.95;
                rotationVelocityY *= 0.95;
            }
            
            // Animar partículas de destello
            if (sparkleMaterial) {
                sparkleMaterial.uniforms.time.value = time;
            }
            
            // Animar halo de brillo
            if (glowSphere) {
                glowSphere.material.uniforms.time.value = time;
                glowSphere.rotation.y = time * 0.5;
                glowSphere.rotation.x = time * 0.3;
            }
            
            // Animar las luces para crear destellos dinámicos
            const keyLight = scene.children.find(child => child instanceof THREE.PointLight && child.color.r === 1);
            if (keyLight) {
                keyLight.intensity = 3 + Math.sin(time * 2) * 0.5;
            }

            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize when page loads
        init();
    </script>
</body>
</html>
